subroutine prompt_player(auxiliary_empty_cells,auxiliary_empty_cells_history,current_empty_cells_history,empty_cells,empty_cells_history,matrix,matrix_history,score_history)
	implicit none!all variables must be declared
	logical::wasd=.false.!if true, the common wasd combination will replace the arrows in teh numpad
	character(4)::input_character='----'!this will be used to pass orders to the program
	integer(4),intent(inout)::auxiliary_empty_cells(0:255)!this vector keeps track of where the index of a certain cell is located in the empty_cells array, for example: empty_cells(0:3)=(/1,3,0,2/) would mean that the values of this array are the following: auxiliary_empty_cells(0:3)=(/2,0,1,3/), thus, only the index of a cell is needed when its interal data are required
	integer(4),intent(inout)::auxiliary_empty_cells_history(0:255,0:99)!same as matrix_history, but the player doesn't interact with this variable, it's only kept so it's faster to move back in the history of movements
	integer(4),intent(inout)::current_empty_cells_history(0:99)!same as matrix_history, but the player doesn't interact with this variable, it's only kept so it's faster to move back in the history of movements
	integer(4),intent(inout)::empty_cells(0:255)!the indeces of empty cells are sequentially kept here with no occupied cells in between, all of those are at the end of the array
	integer(4),intent(inout)::empty_cells_history(0:255,0:99)!same as matrix_history, but the player doesn't interact with this variable, it's only kept so it's faster to move back in the history of movements
	integer(4),intent(inout)::matrix(0:15,0:15)!all the number cells are here
	integer(4),intent(inout)::matrix_history(0:15,0:15,0:99)!history of player movements, when stored movements reach 99, it saves the next snapshot of the matrix in 0, overwriting the previous value, and starts overwriting the next ones as more snapshots are generated by the player
	integer(4)::score!this keeps the puntuation of the game
	integer(4),intent(inout)::score_history(0:99)!same as matrix_history, but the player doesn't interact with this variable, it's only kept so it's faster to move back in the history of movements
	common /score/ score!this subroutine needs the score variable

	write(*,*) 'set title "Score:',score,'\nYou can just introduce h to get help at any moment."'!instructions for the player
	write(*,*) 'replot'!updating the output
10	read(*,*) input_character!reading player command
	if((input_character(1:1)=='8').or.((input_character(1:1)=='w').and.(wasd)))then
		call move_up(auxiliary_empty_cells,auxiliary_empty_cells_history,current_empty_cells_history,empty_cells,empty_cells_history,matrix,matrix_history,score_history)!all cells will move up
	else if((input_character(1:1)=='2').or.((input_character(1:1)=='s').and.(wasd)))then
		call move_down(auxiliary_empty_cells,auxiliary_empty_cells_history,current_empty_cells_history,empty_cells,empty_cells_history,matrix,matrix_history,score_history)!all cells will move down
	else if((input_character(1:1)=='4').or.((input_character(1:1)=='a').and.(wasd)))then
		call move_left(auxiliary_empty_cells,auxiliary_empty_cells_history,current_empty_cells_history,empty_cells,empty_cells_history,matrix,matrix_history,score_history)!all cells will move left
	else if((input_character(1:1)=='6').or.((input_character(1:1)=='d').and.(wasd)))then
		call move_right(auxiliary_empty_cells,auxiliary_empty_cells_history,current_empty_cells_history,empty_cells,empty_cells_history,matrix,matrix_history,score_history)!all cells will move right
	else if((input_character(1:1)=='s').or.((input_character=='save').and.(wasd)))then
		call save_game(auxiliary_empty_cells,auxiliary_empty_cells_history,current_empty_cells_history,empty_cells,empty_cells_history,matrix,matrix_history,score_history)!saving the current game to a file
	else if(input_character(1:1)=='l')then
		call load_game(auxiliary_empty_cells,auxiliary_empty_cells_history,current_empty_cells_history,empty_cells,empty_cells_history,matrix,matrix_history,score_history,.false.)!loading an old game
	else if(input_character(1:1)=='n')then
		call new_game(auxiliary_empty_cells,auxiliary_empty_cells_history,current_empty_cells_history,empty_cells,empty_cells_history,matrix,matrix_history)!starting a new game
	else if(input_character(1:1)=='b')then
		call move_back(auxiliary_empty_cells,auxiliary_empty_cells_history,current_empty_cells_history,empty_cells,empty_cells_history,matrix,matrix_history,score_history)!going back one step in history
	else if(input_character(1:1)=='h')then
		call help(.false.)!getting help
		write(*,*) 'set title "Score:',score,'\nYou can just introduce h to get help at any moment."'!instructions for the player
		write(*,*) 'replot'!updating the output
		go to 10!going back to read another command
	else if(input_character(1:1)=='q')then
		write(*,*) 'set title "Press any key to exit. Bye and see you soon!"'!saying goodbye
		write(*,*) 'replot'!updating the output
		read(*,*) !exiting
		stop!terminating the program
	else if(input_character=='wasd')then
		wasd=.not.wasd!switching the value of wasd between using the numpad or the wasd keys
		go to 10!going back to read another command
	else
		write(*,*) 'set title "There are no actions associated with what you just typed: ',input_character,'\nTry again."'!wrong input
		write(*,*) 'replot'!updating the output
		go to 10!cycling through this if loop till a valid input is obtained
	end if
	return
end subroutine prompt_player
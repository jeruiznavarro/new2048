subroutine move_back(auxiliary_empty_cells,auxiliary_empty_cells_history,current_empty_cells_history,empty_cells,empty_cells_history,matrix,matrix_history,score_history)
	implicit none!all variables must be declared
	integer(4),intent(inout)::auxiliary_empty_cells(0:255)!this vector keeps track of where the index of a certain cell is located in the empty_cells array, for example: empty_cells(0:3)=(/1,3,0,2/) would mean that the values of this array are the following: auxiliary_empty_cells(0:3)=(/2,0,1,3/), thus, only the index of a cell is needed when its interal data are required
	integer(4),intent(inout)::auxiliary_empty_cells_history(0:255,0:99)!same as matrix_history, but the player doesn't interact with this variable, it's only kept so it's faster to move back in the history of movements
	integer(4)::cells!number of cells per side of the square to be used in the game
	integer(4)::current_empty_cells!this is the amount of empty cells in a certain moment
	integer(4),intent(inout)::current_empty_cells_history(0:99)!same as matrix_history, but the player doesn't interact with this variable, it's only kept so it's faster to move back in the history of movements
	integer(4),intent(inout)::empty_cells(0:255)!the indeces of empty cells are sequentially kept here with no occupied cells in between, all of those are at the end of the array
	integer(4),intent(inout)::empty_cells_history(0:255,0:99)!same as matrix_history, but the player doesn't interact with this variable, it's only kept so it's faster to move back in the history of movements
	integer(4)::history_position!this variable keeps track of where should the program write in the history arrays
	integer(4)::i=0!first auxiliary index for the matrix
	integer(4)::input=0!number of steps to go back in history
	integer(4)::input_sum=0!sum of all the inputs, it must never be smaller than 0
	integer(4)::j=0!second auxiliary index for the matrix
	integer(4),intent(inout)::matrix(0:15,0:15)!all the number cells are here
	integer(4),intent(inout)::matrix_history(0:15,0:15,0:99)!history of player movements, when stored movements reach 99, it saves the next snapshot of the matrix in 0, overwriting the previous value, and starts overwriting the next ones as more snapshots are generated by the player
	integer(4)::moves_left_backwards=0!amount of possible movements behind the current one
	integer(4)::moves_left_forwards=0!amount of possible movements ahead of the current one
	integer(4)::score!this keeps the puntuation of the game
	integer(4),intent(inout)::score_history(0:99)!same as matrix_history, but the player doesn't interact with this variable, it's only kept so it's faster to move back in the history of movements
	integer(4)::snapshots!this is the amount of movements stored in the third index of matrix_history, when it reaches 100 it doesn't increase anymore
	integer(4)::temporary_position=0!this will be used to look into the history and show the player different configurations so s/he can decide which one s/he wants
	common /basic/ cells,current_empty_cells,history_position,snapshots!sharing the variables needed for this subroutine except score
	common /score/ score!sharing the score variable too

	moves_left_backwards=snapshots-1!resetting the amount of movements behind the current one
	moves_left_forwards=0!resetting the amount of movements ahead of the current one
	input_sum=0!resetting the sum of the inputs
	temporary_position=history_position!setting the temporary target as the current position in history
	write(*,*) 'set title "How many movements do you want to go back?\n0 saves the changes and goes back to playing, and 1000 calls the help screen.\nNegative numbers move forward, but not through the last movement.\nThere are',moves_left_backwards,' movements left behind the current one\nand',moves_left_forwards,' movements left ahead of the current one."'!asking the player what the program should do
	write(*,*) 'replot'!updating the output
10	read(*,*) input!reading the number of steps to go back
	if(input_sum+input<0)then
		write(*,*) 'set title "Wrong input, right now it must be bigger than',-input_sum-1,'.\nYou want to move back too much, try again moving less or moving forward."'!invalid input
		write(*,*) 'replot'!updating the output
		go to 10!cycling through this if loop till a valid input is obtained
	else if(input_sum+input>99)then
		write(*,*) 'set title "Wrong input, right now it must be smaller than',100-input_sum,'.\nYou want to move forward too much, try again moving less or moving backwards."'!invalid input
		write(*,*) 'replot'!updating the output
		go to 10!cycling through this if loop till a valid input is obtained
	end if
	input_sum=input_sum+input!summing the inputs
	temporary_position=temporary_position-input!this is the position that has been selected by the player
	moves_left_backwards=moves_left_backwards-input!updating the movements behind the current one
	moves_left_forwards=moves_left_forwards+input!updating the movements ahead of the current one
	if(temporary_position<0)then
		temporary_position=temporary_position+100!correcting the position to avoid segmentation faults
	else if(temporary_position>99)then
		temporary_position=temporary_position-100!correcting the position to avoid segmentation faults
	end if
	if((input==0).and.(input_sum==0))then
		return!going back to the main program
	else if(input==0)then
		do j=0,cells-1
			do i=0,cells-1
				matrix(i,j)=matrix_history(i,j,temporary_position)!updating the main matrix with the historical one
			end do
		end do
		do i=0,cells**2-1
			empty_cells(i)=empty_cells_history(i,temporary_position)!same for the empty_cells array
			auxiliary_empty_cells(i)=auxiliary_empty_cells_history(i,temporary_position)!and for the auxiliary one too
		end do
		current_empty_cells=current_empty_cells_history(temporary_position)!updating the amount of empty cells
		score=score_history(temporary_position)!updating the score to the selected one
		snapshots=snapshots-input_sum!updating the amount of snapshots in the history
		history_position=temporary_position!and moving the current position in the history to the right place
		return!going back to the main program
	else if(input==1000)then
		call help()!getting help
		go to 10!going back to read another command
	else
		call output(cells,matrix_history(0:15,0:15,temporary_position))!showing the selected configuration
		write(*,*) 'set title "This is the matrix of the movement you wanted.\n0 saves the changes and goes back to playing, and 1000 calls the help screen.\nNegative numbers move forward, but not through the last movement.\nThere are',moves_left_backwards,' movements left behind the current one\nand',moves_left_forwards,' movements left ahead of the current one."'!asking the player what the program should do
		write(*,*) 'replot'!updating the output
		go to 10!going back to read another command
	end if
end subroutine move_back